<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Model Viewer - Sprite</title>
    <script type="importmap">
    {
    "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.179.0/build/three.module.js",
        "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.179.0/examples/jsm/"
    }
    }
    </script>
    <script src="https://cdn.socket.io/4.8.1/socket.io.min.js"></script>

</head>

<body>
    <script type="module">
        const width = {{SCREEN_WIDTH}};
        const height = {{SCREEN_HEIGHT}};
        import { VRButton } from "three/addons/webxr/VRButton.js";
        import { XRControllerModelFactory } from "three/addons/webxr/XRControllerModelFactory.js";
        import * as THREE from "three";
        const socket = io({transports: ['websocket']});
        

        // Initialize renderer with optimal settings
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: "high-performance",
            alpha: true
        });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        renderer.xr.enabled = true;
        renderer.autoClear = true; // Changed back to true to ensure proper clearing

        document.body.appendChild(renderer.domElement);
        document.body.appendChild(VRButton.createButton(renderer));

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(110, window.innerWidth / window.innerHeight);
        let raycaster, controller1, controller2, controllerGrip1, controllerGrip2;
        let marker, floor, baseReferenceSpace, INTERSECTION;
        const tempMatrix = new THREE.Matrix4();
        
        socket.on('connect', () => {
            console.log("Connected to server");
            socket.emit('camera_data', JSON.stringify({
                position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                quaternion: { w: camera.quaternion.w, x: camera.quaternion.x, y: camera.quaternion.y, z: camera.quaternion.z }
            }));
        });
        socket.on('disconnect', () => console.log("Disconnected from server"));

        // Create Sprites with DataTextures for left and right eyes
        const backendData = new Uint8Array(width * height * 4);
        const texture = new THREE.DataTexture(backendData, width, height, THREE.RGBAFormat);
        // const texture = new THREE.Texture();
        texture.minFilter = THREE.LinearFilter;
        texture.magFilter = THREE.LinearFilter;

        const leftMaterial = new THREE.SpriteMaterial({ map: texture });
        const leftSprite = new THREE.Sprite(leftMaterial);
        leftSprite.scale.set(16, 9, 1);
        leftSprite.position.set(-0.03, 0, -1); // Closer to camera
        leftSprite.layers.set(1);
        camera.add(leftSprite); // Attach to camera


        const rightMaterial = new THREE.SpriteMaterial({ map: texture });
        const rightSprite = new THREE.Sprite(rightMaterial);
        rightSprite.scale.set(16, 9, 1);
        rightSprite.position.set(0.03, 0, -1); // Closer to camera
        rightSprite.layers.set(2);
        camera.add(rightSprite); // Attach to camera

        scene.add(camera); // Ensure camera is in the scene
        camera.layers.enable(1);
        camera.layers.enable(2);
        marker = new THREE.Mesh(
            new THREE.CircleGeometry(0.25, 32).rotateX(-Math.PI / 2),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, side: THREE.DoubleSide , transparent: true, opacity: 1.0 })
        );
        marker.material.depthTest = false;
        marker.material.depthWrite = false;
        marker.renderOrder = 1000;
        scene.add(marker);

        floor = new THREE.Mesh(
            new THREE.PlaneGeometry(1000, 1000, 50,50).rotateX(-Math.PI / 2),
            new THREE.MeshBasicMaterial({ color: 0x000000,wireframe: true})
        );
        floor.material.depthTest = false;   // ignores depth buffer
        floor.renderOrder = 999;   
        scene.add(floor);

        raycaster = new THREE.Raycaster();
        const sendInterval = 1000 / 20; // 20 Hz
        let lastPosition = camera.position.clone();
        let lastQuaternion = camera.quaternion.clone();
        let lastSendTime = 0;

        
        function onSelectStart() { this.userData.isSelecting = true; }
function onSelectEnd() {
    this.userData.isSelecting = false;
    if (INTERSECTION) {
        const offsetPosition = { x: -INTERSECTION.x, y: -INTERSECTION.y, z: -INTERSECTION.z, w: 1 };
        const offsetRotation = new THREE.Quaternion();
        const transform = new XRRigidTransform(offsetPosition, offsetRotation);
        const teleportSpaceOffset = baseReferenceSpace.getOffsetReferenceSpace(transform);
        renderer.xr.setReferenceSpace(teleportSpaceOffset);
        }
    }

        controller1 = renderer.xr.getController(0);
        controller1.addEventListener("selectstart", onSelectStart);
        controller1.addEventListener("selectend", onSelectEnd);
        scene.add(controller1);

        controller2 = renderer.xr.getController(1);
        controller2.addEventListener("selectstart", onSelectStart);
        controller2.addEventListener("selectend", onSelectEnd);
        scene.add(controller2);

        const controllerModelFactory = new XRControllerModelFactory();
        controllerGrip1 = renderer.xr.getControllerGrip(0);
        controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
        scene.add(controllerGrip1);

        controllerGrip2 = renderer.xr.getControllerGrip(1);
        controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
        scene.add(controllerGrip2);


        renderer.setAnimationLoop((timestamp, frame) => {


            INTERSECTION = undefined;
            if (controller1.userData.isSelecting) {
                tempMatrix.identity().extractRotation(controller1.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(controller1.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                const intersects = raycaster.intersectObjects([floor]);
                if (intersects.length > 0) INTERSECTION = intersects[0].point;
            } else if (controller2.userData.isSelecting) {
                tempMatrix.identity().extractRotation(controller2.matrixWorld);
                raycaster.ray.origin.setFromMatrixPosition(controller2.matrixWorld);
                raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
                const intersects = raycaster.intersectObjects([floor]);
                if (intersects.length > 0) INTERSECTION = intersects[0].point;
            }

            if (INTERSECTION) marker.position.copy(INTERSECTION);
            marker.visible = INTERSECTION !== undefined;


            renderer.render(scene, camera);

            if (renderer.xr.isPresenting && frame) {
                const now = performance.now();
                if (now - lastSendTime >= sendInterval) {
                    const posChanged = !camera.position.equals(lastPosition);
                    const quatChanged = !camera.quaternion.equals(lastQuaternion);
                    
                    if (posChanged || quatChanged) {
                        socket.emit('camera_data', JSON.stringify({
                            position: { x: camera.position.x, y: camera.position.y, z: camera.position.z },
                            quaternion: { w: camera.quaternion.w, x: camera.quaternion.x, y: camera.quaternion.y, z: camera.quaternion.z }
                        }));
                        lastPosition.copy(camera.position);
                        lastQuaternion.copy(camera.quaternion);
                        lastSendTime = now;
                    }
                }
            }
        });

        socket.on('image_update', async (arrayBuffer) => {
            const start = performance.now();
            console.log("New Images Received");
            const backendRGBA = new Uint8Array(arrayBuffer);
            backendData.set(backendRGBA);
            texture.needsUpdate = true;
            // const img = new Image();
            // img.src = "data:image/webp;base64," + data.image;
            // await img.decode();
            // texture.image = img;
            // texture.needsUpdate = true;
            // Log pixel data for debugging
            console.log("Updated new images");
            const end = performance.now();
            console.log(`Image update processing time: ${(end - start).toFixed(2)} ms`);

        });



        renderer.xr.addEventListener('sessionstart', () => {
            console.log("VR session started");
            baseReferenceSpace = renderer.xr.getReferenceSpace();
        });
    </script>
</body>

</html>